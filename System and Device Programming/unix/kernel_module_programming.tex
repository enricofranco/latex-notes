\chapter{Kernel Module Programming}
In kernel programming, canonical standard functions and libraries are not available. Hence, no \texttt{printf} is available, it is needed to use \texttt{printk} which is a macro used for debugging purposes. Some common functions are implemented inside the kernel. Furthermore, there is no memory protection, just a small and fixed size stack is available and synchronization and concurrency issues has to be managed.

\texttt{printk} is similar to the more common \texttt{printf}, but it is preceded by a constant defining the priority level. In the examples, \texttt{KERN\_INFO} has been used, which identifies a low level priority.

\begin{table}
\centering
\begin{tabular}{|c|c|}
\hline 
Application & User space \\
\hline 
System call & \multirow{2}{*}{Kernel space} \\
Device drivers & \\
\hline 
\end{tabular}
\caption{I/O architecture}
\label{tab:io_architecture}
\end{table} 

UNIX has a monolitic kernel compiled using a set modules always present. Micro kernel is an alternative architecture where kernel is reduced to the minimum function of passing messages among system processes and drivers. Micro kernel is appealing from a theoretical point of view but it suffers efficiency issues.

\paragraph{Commands}
\begin{itemize}
\item \texttt{lsmod} provides the entire list of installed modules;
\item \texttt{insmod} or \texttt{modprobe} permit to install a modules. They require as a parameter a \texttt{ko} file, i.e.\@ kernel object;
\item \texttt{depmode} builds a list of module dependencies. It require as a parameter a \texttt{ko} file, i.e.\@ kernel object.
\item \texttt{rmmod} removes a module.  It requires as a parameter the name of an installed module.
\end{itemize}

Output generated by modules goes in \texttt{/var/log/messages} and it is readable through command \texttt{dmesg}, eventually piped to \texttt{tail}.

\texttt{init\_module} increases reference counter, while \texttt{cleanup\_module} decreases it. Macros \texttt{\_\_init} and \texttt{\_\_exit} followed by the function name hint to the kernel that the given function is used only once, the kernel module loader than releases their memory, for built-in drivers only.

Makefiles are provided and contain the directive \texttt{uname -r} which shows the kernel version in use.

\paragraph{Parameters}
Parameters are stored in \texttt{sys/module/<name>/parameters}. It is possible to infer them during the module installation by simply adding their declarations.

\paragraph{Special files for devices} Major and minor numbers related to devices are stored in file
\texttt{/usr/src/linux/Documentation/devices.txt}. In order to create a new special file, \texttt{mknod} must be used indicating major and minor numbers as follow: \texttt{mknod /dev/<device> c <major> <minor>}. Kernel uses the major number to determine which driver will be used. The drive deals with the minor number to distinguish between different devices of the same type.

\paragraph{Character device files}
C99 way to assign functions to the fields of this structure:
\begin{verbatim}
struct file_operations fops = {
  .read = device_read;
  .write = device_write;
  .open = device_open;
  .release = device_release
};
\end{verbatim}
\texttt{struct file\_operations} is defined in \texttt{/usr/src/linux/include/fs.h}.

\paragraph{Registering a device driver}
Registering a device driver means assigning a major and minor number during the initialization of a module. It is possible to ask the kernel to assign a dynamic major number by using \\
\texttt{alloc\_chrdev\_region(\&dev\_no, firstminor, num\_minors, DEVICE\_NAME)}.

In order create the device file, it is needed to get the major number dynamically assigned. Device file has to be created by hand, by reading the new assigned major number in \texttt{/var/log/messages} printed by the driver or by using the entry created in \texttt{/proc/devices}.

\paragraph{Unregistering a device driver}
A kernel module cannot be removed if a device driver is opened by a process because a successive system call would be directed to a memory location where the appropriate function does not exist any more. The \texttt{cleanup\_module} has \texttt{void} type, thus it cannot return -1. The third field in \texttt{/proc/modules} is a counter of the number of processes that are using a module. The counter is managed by means of \texttt{try\_module\_get(THIS\_MODULE)} to increment the count and \texttt{module\_put(THIS\_MODULE)} to decrement the count.

\paragraph{Moving data between user and kernel space}
\texttt{put} and \texttt{get} are seen from the kernel point of view:

\begin{itemize}
\item \texttt{put\_user(k, u)} copies one character from the kernel data segment to the user data segment;
\item \texttt{get\_user(k, u)} copies one character from the user data segment to the kernel data segment.
\end{itemize}

\paragraph{\texttt{/proc} filesystem}
The \texttt{/proc} filesystem contains a directory for each active process. It is an additional mechanism for the kernel and its modules to give information of processes. 
\begin{itemize}
\item \texttt{/proc/modules}
\item \texttt{/proc/meminfo}
\end{itemize}