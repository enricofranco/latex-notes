\chapter{Structured exception handling}
\emph{Structured Exception Handling (SEH)} provides a robust mechanism for application to respond to unexpected events, e.g.\@ hardware faults, addressing exceptions, system errors or user generated exception. It assures the ability to free resources, i.e.\@ it performs clean-up, and simplifies program logic.

\section{Exception handlers}
\paragraph{Try and except blocks}
\texttt{\_\_try} and \texttt{\_\_except} are keywords recognized by Visual C++ compiler. Actual keywords are specific to the compiler.

\begin{verbatim}
__try {
  /* Block of monitored code */
}
__except {
  /* Exception handling block */
}
\end{verbatim}

\paragraph{Filter expressions}
The \texttt{filter\_expression} is evaluated after an exception. It is a literal constant, expression, or a function call. It returns one of three values:
\begin{itemize}
\item \texttt{EXCEPTION\_EXECUTE\_HANDLER}: normal case;
\item \texttt{EXCEPTION\_CONTINUE\_SEARCH}: this handler does not process this exception; unwind the stack for the next exception handler;
\item \texttt{EXCEPTION\_CONTINUE\_EXECUTION}: not a problem.
\end{itemize}
Some exception cannot be continued, and another exception would occur immediately.

\paragraph{Exception codes} \texttt{DWORD GetExceptionCode (VOID)}. The filter function itself cannot call \texttt{GetExceptionCode}, so a common usage is:
\begin{verbatim}
__except (MyFilter (GetExceptionCode ())) {
  ...
}
\end{verbatim}
An alternative function that returns additional information is
\begin{verbatim}
LPEXCEPTION_POINTERS GetExceptionInformation (VOID)
\end{verbatim}
which includes information on the virtual address causing an access violation.

\subparagraph{Exception code values}
\begin{enumerate}
\item Program violations, including:
\begin{itemize}
\item \texttt{EXCEPTION\_ACCESS\_VIOLATION};
\item \texttt{EXCEPTION\_DATATYPE\_MISALIGNMENT};
\item \texttt{EXCEPTION\_NONCONTINUABLE\_EXECUTION};
\end{itemize}
\item Memory allocation exceptions (\texttt{HeapAlloc} and \texttt{HeapCreate})
\begin{itemize}
\item \texttt{STATUS\_NO\_MEMORY};
\end{itemize}
\item User-defined exception codes;
\item Arithmetic codes such as:
\begin{itemize}
\item \texttt{EXCEPTION\_INT\_DIVIDE\_BY\_ZERO};
\item \texttt{EXCEPTION\_FLT\_DIVIDE\_BY\_ZERO};
\end{itemize}
\item Debugger exceptions: \texttt{EXCEPTION\_BREAKPOINT}.
\end{enumerate}

\subsection{User-generated exceptions}
\begin{verbatim}
VOID RaiseException (
  DWORD dwExceptionCode,
  DWORD dwExceptionFlags,
  DWORD cArguments,
  LPDWORD lpArguments
);
\end{verbatim}

\paragraph{Parameters}
\begin{description}
\item [\texttt{dwExceptionCode}] An application-defined exception code of the exception being raised. Typical value is \texttt{0xE0000006}. Refer to table~\ref{tab:dwExceptionCode}.
\item [\texttt{dwExceptionFlags}] \texttt{EXCEPTION\_NONCONTINUABLE} specifies that filter expression should not generate \texttt{EXCEPTION\_CONTINUE\_EXECUTION}.
\item [\texttt{cArguments}] The number of arguments in the \texttt{lpArguments} array. This value must not exceed \texttt{EXCEPTION\_MAXIMUM\_PARAMETERS}, i.e.\@ 15.
\item [\texttt{lpArguments}] Pointer to an array of \texttt{cArguments} elements. These arguments can contain any application-defined data that needs to be passed to the filter expression of the exception handler.
\end{description}

\begin{table}
\centering
\label{tab:dwExceptionCode}
\begin{tabular}{|c|c|c|c|}
\hline 
31 - 30 & 29 & 28 & 27 ... 0 \\ 
\hline 
0 - Success & \multirow{4}{*}{1} & \multirow{4}{*}{0} & \multirow{4}{*}{User specified} \\ 
\cline{1-1} 
1 - Informal & & & \\ 
\cline{1-1} 
2 - Warning & & & \\ 
\cline{1-1} 
3 - Error & & & \\ 
\hline
\end{tabular} 
\caption{dwExceptionCode}
\end{table}

\begin{verbatim}
VOID ReportException (LPCTSTR UserMessage, DWORD ExceptionCode) {
  if (lstrlen (UserMessage) > 0)
    ReportError (UserMessage, 0, TRUE);
  if (ExceptionCode != 0)
    RaiseException ((0x0FFFFFFF & ExceptionCode) |
      0xE0000000, 0, 0, NULL);
  return;
}
\end{verbatim}
\texttt{ReportException} is an extension of \texttt{ReportError} to generate a user exception code rather then terminating. An exception is raised and its code is generated by masking any high order bits in the user-supplied exception code.

\paragraph{Parameters}
\begin{description}
\item [\texttt{UserMessage}] Message to be displayed.
\item [\texttt{ExceptionCode}] If greater than 0, exit process with this code.
\end{description}

\subsubsection{Enabling floating point exceptions}
To enable floating point exceptions, it is needed to set the \texttt{fp mask}.
\begin{verbatim}
int iFPMask = _controlfp (0, 0);
ifpMask &= ~(EM_OVERFLOW | EM_UNDERFLOW | EM_INEXACT |
EM_ZERODIVIDE | EM_DENORMAL);
_controlfp (iFPMask, MCW_EM); /* Set the new control mask */
_controlfp (iFPMask, 0xFFFFFFFF); /* Restore the old mask */
\end{verbatim}
General formula: \texttt{(current\_mask \& \~{}mask) | (new \& mask)}.

After a floating point exception, clear it with \texttt{\_clearfp()}.

\section{Termination handlers}
\emph{Termination handlers} are executed whenever control flow leaves the \texttt{try} block because of:
\begin{itemize}
\item Reaching the end of the \texttt{\_\_try} block;
\item Leaving the block because of execution of \texttt{return}, \texttt{break}, \texttt{longjump}, \texttt{continue}, \texttt{goto} or \texttt{\_\_leave};
\item An exception.
\end{itemize}
A termination handler is executed in the context of the block or function it guards. Control can pass from end of termination handler to next statement.

\paragraph{Try-Finally blocks}
\begin{verbatim}
while (...) __try {
  hTemp = CreateFile (TempFileName, ...);
  /* Block of guarded code */
  if (...) break; /* Finally block will run */
  ...
}
__finally { /* Executed on every loop iteration */
  /* Termination handler (finally block) */
  CloseHandle (hTemp);
  DeleteFile (TempFileName);
}
\end{verbatim}