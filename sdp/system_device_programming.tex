\documentclass{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{url}
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{multirow}
\usepackage{parallel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Enrico Franco}
\title{System and Device Programming \\
	Prof. Laface Pietro \\
	Lectures notes}
\begin{document}
\maketitle
\tableofcontents

\include{processes_concurrency}
\include{threads}
\include{synchronization}
\include{memory_management_unit}
\include{virtual_memory}
\include{device_management}

\chapter{File system}
The \emph{file system} is a layer of OS which transforms block interface of disks (or other block devices) into files, directories, etc.
A \emph{file} is an abstract data type that associates the name to its data. Data are normally referred as record but they are organized in blocks. There is no correspondence between blocks and records. Blocks are not accessed directly, because in between there are strategies on how accessing the block which may optimize the block access.

\section{Overview}
File systems have traditionally divided the disk into equally sized blocks to simplify their design and limit the worst-case fragmentation. When files are allocated, only whole blocks can be allocated to individual files. But, as file sizes are often not multiples of the file system block size, this design inherently results in the last blocks of files  occupying only a part of the block, resulting in what is called \emph{internal fragmentation}. This waste of space can be significant if the file system stores many small files and can become critical when attempting to use higher block sizes to improve performance.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.4]{images/file_system/logical_level_file_access.png}
\caption{Logical levels for file access}
\end{figure}

\subsection{Regular file}
Data in a file are reachable using common operations such as creation, writing, reading, deleting, etc.

Different OSs keep track of different file attributes, including:
\begin{itemize}
\item File type;
\item File system type;
\item Volume;
\item Starting address;
\item Size;
\item Owner;
\item Access rights;
\item Use information (when/who has last written/read/modified the file or its attributes).
\end{itemize}
Files are organized in directories and subdirectories.

\subsection{Disk file organization}
There are three major methods to store files on disks: contiguous, linked and indexed.

\subsubsection{Contiguous allocation}
Contiguous allocation requires that all blocks of a file are kept together one after the other. In this way, access is very fast because reading consecutive blocks requires no movement of the disk heads or one small step to the next adjacent cylinder.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.35]{images/file_system/contiguous_allocation.png}
\caption{Contiguous allocation}
\end{figure}

This type of allocation has the same issues of the contiguous allocation in main memory (e.g.\@ first fit, best fit, fragmentation problems). Problems can arise when files grow, or if the exact file size is unknown at creation time. In fact, an over-estimation will cause external fragmentation and space waste, while under-estimation may cause the relocation of the file.

\subsubsection{Linked allocation}
Disk files can be stored as linked lists, with the expense of the storage space consumed by each link (i.e.\@ for each block, 4 bytes are lost to store the address of next block). Linked allocation has no external fragmentation, does not require to know a priori the file size and, therefore, allows files to grow dynamically. This allocation permits only sequential access to files because it is needed to traverse the entire series of blocks and it is dangerous because administration data (link) together with user data and it has the disadvantage that, if a pointer is lost or damaged, the entire file is unreachable and corrupted.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.35]{images/file_system/linked_allocation.png}
\caption{Linked allocation}
\end{figure}

The \textbf{File Allocation Table (FAT)}, adopted by \emph{DOS file system}, is an improvement to basic linked allocation. The main idea is to separate administration data from user data adopted. Directories are associated with a number representing both the pointer to the first block of data and an index into FAT. Each entry of the FAT contains the index of next block, providing separation between administration and user data and immediate access to the first block. Therefore, small files (which are the most common) can be immediately referenced.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.35]{images/file_system/fat.png}
\caption{File Allocation Table (FAT)}
\end{figure}

\subsubsection{Indexed allocation}
Indexed allocation keeps all the indexes into a single block (i.e. block of indexes) for each file instead of spreading them all over the file system or storing them in a FAT. When a file is opened, its index block is opened too and it is possible to access the its blocks wherever they are. Some disk space is wasted because an entire index block must be allocated for each files. There are several approaches to implement the index block:
\begin{itemize}
\item Linked Scheme: An index block is one disk block, which can be read and written in a single disk operation. The first index block contains some header information, the first N block addresses, and if necessary a pointer to additional linked index blocks;
\item Multi-Level Index: The first index block contains a set of pointers to secondary index blocks, which in turn contain pointers to the actual data blocks.
\end{itemize}

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.35]{images/file_system/indexed_allocation.png}
\caption{Indexed allocation}
\end{figure}

\section{UNIX file system organization}
UNIX adopts a \emph{combined scheme} in its inodes. In fact, it stores 10 data block pointers directly in the inode, and then singly, doubly and triply indirect pointers provide access to more data blocks as needed.

\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline 
Boot block & Superblock & Inode list & Data blocks \\ 
\hline 
\end{tabular} 
\end{center}

\begin{itemize}
\item The first block is the \emph{boot block} containing the bootstrap code loaded and executed at system power on.
\item The \emph{superblock} describes the file system state, i.e.\@ size, number of files included, free list of inodes and data blocks, etc.
\end{itemize}

\paragraph{Inode} The \emph{inode} contains information about the owner, file type (regular, directory, special, \dots), access rights, access times, link number, file size and table of the data block addresses on disk. Those information can be retrieved exploiting command \texttt{ls -l}.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.35]{images/file_system/unix_combined_scheme.png}
\caption{The UNIX allocation of disk space}
\end{figure}

\subsection{Functions for file system management}
Table~\ref{system_mgmt_upper_layers} includes functions directly used by system calls, which exploit functionality provided by procedures contained in table~\ref{system_mgmt_lower_layers}. Here, the functions placed at the lower layer, are used directly by the buffer cache, e.g.\@ get block, block release, block read. The most used is \texttt{getblk} used to retrieve a block at any access. Those functions are exploited by some allocation algorithms, placed on top of them, e.g.\@ copy, delayed write.

\begin{table}
\centering
\begin{tabular}{|c|c|c|cc|cc|}
\hline 
\multicolumn{3}{|c|}{\texttt{namei}} & \multirow{2}{*}{\texttt{alloc}} & \multirow{2}{*}{\texttt{free}} & \multirow{2}{*}{\texttt{ialloc}} & \multirow{2}{*}{\texttt{ifree}} \\\cline{1-3} 
\texttt{iget} & \texttt{iput} & \texttt{bmap} & & & & \\ 
\hline 
\end{tabular}
\caption{Upper layers}
\label{system_mgmt_upper_layers}
\end{table} 

\begin{table}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline 
\multicolumn{5}{|c|}{buffer allocation algorithm} \\ 
\hline 
\texttt{getblk} & \texttt{brelse} & \texttt{bread} & \texttt{breada} & \texttt{bwrite} \\ 
\hline 
\end{tabular} 
\caption{Lower layers}
\label{system_mgmt_lower_layers}
\end{table}

\paragraph{\texttt{iget}} It is called by system call \texttt{open}. It locks the inode, allocates in memory a copy of the inode describing a file and returns an unlocked inode with reference count incremented by one. If the inode free list is empty, the kernel returns an error.

\paragraph{\texttt{iput}} It is called by system call \texttt{close}. It locks the inode and decrements the reference count by one. If the reference count is 0, the inode is written on disk if modified and its copy is released from the inode free list. If the link~count \footnote{Number of names referring to that object.} is 0, the kernel releases all the data blocks of the file and its disk inode.

Reference counter and link counter may differ, for example, if a file is created (system call \texttt{creat}) and immediately unlinked the reference counter is one while the link counter is zero. In this case, only the process creating the file has the possibility to access the file because it knows its file descriptor, thus it may use the file as a temporary one. When the process closes (system call \texttt{close}) the file, both reference and link counters are zero and, therefore, the kernel can remove the file.

\paragraph{\texttt{bmap}} It converts the file offset in the corresponding physical block on disk. Given the offset, it uses the inode pointers to identify disk block where the information is stored and returns a pointer to the disk block.

\paragraph{\texttt{namei}} It returns the inode of a file, given its pathname. It analyzes a pathname component at a time and finds the corresponding inode. The pointer to the inode of the process working directory is stored in the user area \footnote{Common kernel memory area to all process. Kernel uses this are to store the parameters of the currently running process}. It implements a non trivial and expensive operation. In fact it is used only once when a file is opened, then the file descriptor is used to reach the file.

\paragraph{\texttt{ialloc}} It is called by system call \texttt{open} with \texttt{O\_CREAT} flag. It assigns a disk inode to a file that has to be created.

\paragraph{\texttt{ifree}} It is called by system call \texttt{unlink}. It releases the inode of a file that has been remove, and is not currently in use, i.e.\@ reference count greater than zero.

\paragraph{\texttt{alloc}} It is called when the file is written and a new data block is needed. It allocates the first free block number in the superblock free list. If this block is the last block available in the superblock's list, it contains all the addresses to free blocks in the disk. Thus, the operating system will use the number of the block as pointer to a block storing the next element of the linked list, which is integrally loaded into the cache and the previous block, now empty, can be allocated for the process which made the request for it.

\paragraph{\texttt{free}} It provides the same functionalities of the \texttt{ifree} routine saw previously.

\subsection{File system system calls}
\begin{itemize}
\item Return a descriptor: \texttt{open}, \texttt{creat}, \texttt{dup}, \texttt{pipe}, \texttt{close};
\item Use \texttt{namei}: \texttt{open}, \texttt{creat}, \texttt{chdir}, \texttt{chroot}, \texttt{chown}, \texttt{chmod}, \texttt{stat}, \texttt{link}, \texttt{unlink}, \texttt{mknod}, \texttt{mount}, \texttt{umount};
\item Allocate inode: \texttt{creat}, \texttt{mknod}, \texttt{unlink};
\item Attributes: \texttt{chown}, \texttt{chmod}, \texttt{stat};
\item I/O: \texttt{read}, \texttt{write}, \texttt{seek};
\item File system structure management: \texttt{mount}, \texttt{umount}, \texttt{chdir}, \texttt{chroot}.
\end{itemize}

\paragraph{open} \texttt{int fd = open(char* pathname, int flags, mode\_t mode);}

It returns a \emph{file descriptor} associated to \texttt{pathname}. The parameter \texttt{flags} must include one of the access modes: \texttt{O\_RDONLY}, \texttt{O\_WRONLY} or \texttt{O\_RDWR} standing for read-only, write-only or read write, respectively. In addition, zero or more file creation flags and file status flags can be bitwise-or'd in \texttt{flags}, e.g.\@ create file if not existing, truncate it, append the content, no writing delay, exclusive access.

\begin{figure}[hbtp]
\centering
\includegraphics[scale=0.4]{images/file_system/open_system_call.jpg}
\caption{UNIX open system call}
\end{figure}

\paragraph{read} \texttt{ssize\_t number = read(int fd, void* buffer, size\_t count);}

It attempts to read up to \texttt{count} bytes from file descriptor \texttt{fd} into the buffer starting at \texttt{buf}. When the functions completes with success, it returns the number of bytes read, and the file position is advanced by this number. The while \texttt{count} cycle ends:
\begin{itemize}
\item because \texttt{count} is satisfied;
\item because of \emph{EOF}, different than reading a block with zero pointer in its node;
\item because of read error from the device;
\item because of error during the copy to the user buffer.
\end{itemize}
The I/O parameters are copied in the user area:
\begin{itemize}
\item \emph{mode}: read or write;
\item \emph{count}: number of bytes to be read or written;
\item \emph{offset}: where to begin the I/O operation;
\item \emph{address}: source or destination;
\item \emph{flag}: kernel or user space;
\item flag directory;
\item possible changed root.
\end{itemize}
If more than one process have to access the same file and one of them wants to access it in write mode, file and record locking have to be used to guarantee the mutual exclusion access.

\subparagraph{Read ahead}
While a process executes the system call \texttt{read} of two logical sequential blocks, the kernel assumes that all its successive calls will be sequential. At every iteration of the reading cycle, the kernel stores the next logical block number in the inode in memory and, in the next iteration, it tests if the current block number is equal to the saved one. If they are equal, the kernel computes the physical block number for the read ahead using \texttt{bmap} routine and stores its value in the user area so that it can be used by \texttt{breada}.

\paragraph{write}
\texttt{ssize\_t write(int fd, const void *buf, size\_t count);}

It writes up to \texttt{count} bytes to the file referenced by the file descriptor \texttt{fd} from the buffer starting at \texttt{buf}. On success, the number of bytes written are returned (zero indicates nothing was written). On error, -1 is returned.

If the write offset does not correspond to an already allocated block, the kernel allocates a new block and updates the pointer structure, possibly allocating one or more indirect blocks. If, instead, the kernel has to write only part of a block, it must read the block from disk. Delayed write is particularly suited to pipes and temporary files.

\paragraph{lseek}
\texttt{off\_t lseek(int fd, off\_t offset, int whence);}

It repositions the file offset of the open file associated with the file descriptor \texttt{fd} to the argument \texttt{offset} according to the directive \texttt{whence} as follows:
\begin{itemize}
\item \texttt{SEEK\_SET}: The file offset is set to \texttt{offset} bytes.
\item \texttt{SEEK\_CUR}: The file offset is set to its current location plus \texttt{offset} bytes.
\item \texttt{SEEK\_END}: The file offset is set to the size of the file plus \texttt{offset} bytes.
\end{itemize}
It allows the file offset to be set beyond the end of the file,but this does not change the size of the file. If data is later written at this point, subsequent reads of the data in the gap (a \emph{hole}) return null bytes until data is actually written into the gap. Upon successful completion, it returns the resulting offset location as measured in bytes from the beginning of the file.  On error, the value -1 is returned.

\paragraph{close}
\texttt{int close(int fd);}

It closes a file descriptor, so that it no longer refers to any file and may be reused. Any record locks held on the file it was associated with, and owned by the process, are removed (regardless of the file descriptor that was used to obtain the lock). If \texttt{fd} is the last file descriptor referring to the underlying open file description, the resources associated with the open file description are freed; if the file descriptor was the last reference to a file which has been removed using \texttt{unlink}, the file is deleted. It returns zero on success. On error, -1 is returned.

If the inode reference count is greater than one, it decrements the counter and return. If the inode reference count is one, the kernel releases, by means of \texttt{iput}, the inode allocated in memory by the \texttt{open} system call, the corresponding entry in the inode table and the entry in the user file description tables. When a process exits, the kernel closes all its file descriptor still open. 

\paragraph{creat}
\texttt{int creat(const char *pathname, mode\_t mode);}

It is equivalent to calling \texttt{open} with flags equal to \texttt{O\_CREAT | O\_WRONLY | O\_TRUNC}. If the file does not exist, it is create with the specified name and mode. The kernel analyzes the pathname by means of \texttt{namei} and when the last component is parsed, it allocates a free inode, it stores the name in the first free entry of the last parsed directory name and opens the file. If the file exists, parsing it pathname, the kernel finds its inode, it initializes the file dimension to 0 and releases all its data blocks.

If the process calling \texttt{creat} has the write permission, and the file exists, the file owner and the access permission do not change. The kernel does not verify that the parent directory of existing file has the write permission because the directory content does not change.

\paragraph{mknod}
\texttt{int mknod(const char *pathname, mode\_t mode, dev\_t dev);}

It creates a filesystem node (file, device special file, or named pipe) named \texttt{pathname}, with attributes specified by \texttt{mode} and \texttt{dev}. The \texttt{mode} argument specifies both the file mode to use and the type of node to be created and it should be a combination (using bitwise OR) of one of the file types listed below and zero or more of the file mode bits. The file type must be one of \texttt{S\_IFREG}, \texttt{S\_IFCHR}, \texttt{S\_IFBLK}, \texttt{S\_IFIFO}, or \texttt{S\_IFSOCK} to specify a regular file (which will be created empty), character special file, block special file, FIFO (named pipe), or UNIX domain socket, respectively. If the file type is \texttt{S\_IFCHR} or \texttt{S\_IFBLK}, then \texttt{dev} specifies the major and minor numbers of the newly created device special file; otherwise it is ignored. It returns zero on success, or -1 if an error occurred.

It may be used to create named pipes which are pipes remaining in the file system and permit communication among processes which are not parent and child.

\paragraph{chdir}
\texttt{int chdir(const char *pathname);}

It shall cause the directory named by the pathname pointed to by the \texttt{pathname} argument to become the current working directory; the starting point for \texttt{pathname} searches for pathnames not beginning with \texttt{/}. Upon successful completion, 0 shall be returned. Otherwise, -1 shall be returned and the current working directory shall remain unchanged. 

The kernel decrements the reference count, releases the old directory inode and stores the inode of the new directory in the user area. The current directory inode is released after the process exits or calls again \texttt{chdir}.

\paragraph{chroot}
\texttt{int chroot(const char *pathname);}

It changes the root directory of the calling process to that specified in \texttt{path}. This directory will be used for pathnames beginning with /. The root directory is inherited by all children of the calling process. On success, zero is returned. On error, -1 is returned. Only privileged process can call \texttt{chroot}.

The kernel keeps a global variable pointer to the root inode. This call does not change the current working directory and does not close open file descriptors.

\paragraph{chown - chmod}
These operations change the inode, not the file content. To change the file owner or permissions, the process must be owner of the file or have superuser privileges. These system calls both return zero on success and -1 on error.
\\
\texttt{int chown(const char *pathname, uid\_t owner, gid\_t group);}

It changes the owner and group of a file specified by \texttt{pathname}.
\\
\texttt{int chmod(const char *pathname, mode\_t mode);}

It changes the permissions of a file specified by \texttt{pathname}.

\paragraph{stat - fstat} These functions return information about a file. No permissions are required on the file itself. These system calls both return zero on success and -1 on error.
\\
\texttt{int stat(const char *pathname, struct stat *buf);}

It stats the file pointed to by \texttt{pathname} and fills in \texttt{buf}.
\\
\texttt{int fstat(int fd, struct stat *buf);}

It is identical to \texttt{stat}, except that the file to be stat-ed is specified by the file descriptor \texttt{fd}.

The \texttt{stat} structure is defined in \texttt{stat.h} as follows:

\begin{verbatim}
struct stat {
  dev_t     st_dev;     /* ID of device containing file */
  ino_t     st_ino;     /* inode number */
  mode_t    st_mode;    /* protection */
  nlink_t   st_nlink;   /* number of hard links */
  uid_t     st_uid;     /* user ID of owner */
  gid_t     st_gid;     /* group ID of owner */
  dev_t     st_rdev;    /* device ID (if special file) */
  off_t     st_size;    /* total size, in bytes */
  blksize_t st_blksize; /* blocksize for file system I/O */
  blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
  time_t    st_atime;   /* time of last access */
  time_t    st_mtime;   /* time of last modification */
  time_t    st_ctime;   /* time of last status change */
};
\end{verbatim}

\end{document}